{"ast":null,"code":"import * as b64 from '@juanelas/base64';\n/**\n * Conversions from/to bingint to TypedArray/Buffer, hex\n *\n * @remarks\n * This module runs perfectly in node.js and browsers\n *\n * @packageDocumentation\n */\n\n/**\n * Converts an arbitrary-size non-negative bigint to an ArrayBuffer or a Buffer (default for Node.js)\n *\n * @param a\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer with a binary representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0.\n */\n\nfunction bigintToBuf(a, returnArrayBuffer = false) {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported');\n  return hexToBuf(bigintToHex(a), returnArrayBuffer);\n}\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (node.js) to a bigint\n * @param buf\n * @returns a bigint\n */\n\n\nfunction bufToBigint(buf) {\n  let bits = 8n;\n  if (ArrayBuffer.isView(buf)) bits = BigInt(buf.BYTES_PER_ELEMENT * 8);else buf = new Uint8Array(buf);\n  let ret = 0n;\n\n  for (const i of buf.values()) {\n    const bi = BigInt(i);\n    ret = (ret << bits) + bi;\n  }\n\n  return ret;\n}\n/**\n * Converts a non-negative bigint to a hexadecimal string\n * @param a - a non negative bigint\n * @returns hexadecimal representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0\n */\n\n\nfunction bigintToHex(a) {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported');\n  return a.toString(16);\n}\n/**\n * Converts a hexadecimal string to a bigint\n *\n * @param hexStr\n *\n * @returns a bigint\n */\n\n\nfunction hexToBigint(hexStr) {\n  return BigInt('0x' + hexStr);\n}\n/**\n * Converts a non-negative bigint representing a binary array of utf-8 encoded text to a string of utf-8 text\n *\n * @param a - A non-negative bigint representing a binary array of utf-8 encoded text.\n *\n * @returns a string text with utf-8 encoding\n *\n * @throws {RangeError}\n * Thrown if a < 0.\n */\n\n\nfunction bigintToText(a) {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported');\n  return bufToText(hexToBuf(a.toString(16)));\n}\n/**\n * Converts a utf-8 string to a bigint (from its binary representaion)\n *\n * @param text - A string text with utf-8 encoding\n *\n * @returns a bigint representing a binary array of the input utf-8 encoded text\n */\n\n\nfunction textToBigint(text) {\n  return hexToBigint(bufToHex(textToBuf(text)));\n}\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (in Node.js) containing utf-8 encoded text to a string of utf-8 text\n *\n * @param buf - A buffer containing utf-8 encoded text\n *\n * @returns a string text with utf-8 encoding\n */\n\n\nfunction bufToText(buf) {\n  return new TextDecoder().decode(new Uint8Array(buf));\n}\n/**\n * Converts a string of utf-8 encoded text to an ArrayBuffer or a Buffer (default in Node.js)\n *\n * @param str - A string of text (with utf-8 encoding)\n * @param returnArrayBuffer - When invoked in Node.js, it can force the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer containing the utf-8 encoded text\n */\n\n\nfunction textToBuf(str, returnArrayBuffer = false) {\n  return new TextEncoder().encode(str).buffer;\n}\n/**\n * Returns the hexadecimal representation of a buffer.\n *\n * @param buf\n *\n * @returns a string with a hexadecimal representation of the input buffer\n */\n\n\nfunction bufToHex(buf) {\n  {\n    let s = '';\n    const h = '0123456789abcdef';\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));else buf = new Uint8Array(buf);\n    buf.forEach(v => {\n      s += h[v >> 4] + h[v & 15];\n    });\n    return s;\n  }\n}\n/**\n * Converts a hexadecimal string to a buffer\n *\n * @param hexStr - A string representing a number with hexadecimal notation\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns An ArrayBuffer or a Buffer\n *\n * @throws {RangeError}\n * Thrown if hexStr is undefined or not a hexadecimal.\n */\n\n\nfunction hexToBuf(hexStr, returnArrayBuffer = false) {\n  if (hexStr === undefined) {\n    throw RangeError('hexStr cannot undefined');\n  }\n\n  const hexMatch = hexStr.match(/^(0x)?([\\da-fA-F]+)$/);\n\n  if (hexMatch == null) {\n    throw RangeError('hexStr must be a hexadecimal string, e.g. \\'0x124fe3a\\' or \\'0214f1b2\\'');\n  }\n\n  let hex = hexMatch[2];\n  hex = hex.length % 2 === 0 ? hex : '0' + hex;\n  {\n    return Uint8Array.from(hex.match(/[\\da-fA-F]{2}/g).map(h => {\n      return parseInt(h, 16);\n    })).buffer;\n  }\n}\n/**\n * Converts an arbitrary-size non-negative bigint to a base64 string\n * @param a - a non negative bigint\n * @param urlsafe - if true Base64 URL encoding is used ('+' and '/' are replaced by '-', '_')\n * @param padding - if false, padding (trailing '=') is removed\n * @returns a base64 representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0\n */\n\n\nfunction bigintToBase64(a, urlsafe = false, padding = true) {\n  return b64.encode(bigintToBuf(a), urlsafe, padding);\n}\n/**\n * Converts a base64 string to bigint.\n * @param a base64 string. It accepts standard and URL-safe base64 with and without padding\n * @returns a bigint\n */\n\n\nfunction base64ToBigint(a) {\n  return bufToBigint(b64.decode(a));\n}\n\nexport { base64ToBigint, bigintToBase64, bigintToBuf, bigintToHex, bigintToText, bufToBigint, bufToHex, bufToText, hexToBigint, hexToBuf, textToBigint, textToBuf }; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguYnJvd3Nlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RzL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpudWxsLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7OztBQWdCQTs7Ozs7Ozs7Ozs7U0FXZ0IsV0FBVyxDQUFFLENBQVMsRUFBRSxvQkFBNkIsS0FBSztJQUN4RSxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQUUsTUFBTSxVQUFVLENBQUMsdUVBQXVFLENBQUMsQ0FBQTtJQUNwRyxPQUFPLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLENBQUMsQ0FBQTtBQUNwRCxDQUFDO0FBRUQ7Ozs7O1NBS2dCLFdBQVcsQ0FBRSxHQUFrQztJQUM3RCxJQUFJLElBQUksR0FBRyxFQUFFLENBQUE7SUFDYixJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDO1FBQUUsSUFBSSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDLENBQUE7O1FBQ2hFLEdBQUcsR0FBRyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQTtJQUU5QixJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUE7SUFDWixLQUFLLE1BQU0sQ0FBQyxJQUFLLEdBQXlCLENBQUMsTUFBTSxFQUFFLEVBQUU7UUFDbkQsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQ3BCLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksRUFBRSxDQUFBO0tBQ3pCO0lBQ0QsT0FBTyxHQUFHLENBQUE7QUFDWixDQUFDO0FBRUQ7Ozs7Ozs7O1NBUWdCLFdBQVcsQ0FBRSxDQUFTO0lBQ3BDLElBQUksQ0FBQyxHQUFHLENBQUM7UUFBRSxNQUFNLFVBQVUsQ0FBQyx1RUFBdUUsQ0FBQyxDQUFBO0lBQ3BHLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQTtBQUN2QixD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","map":null,"metadata":{},"sourceType":"module"}