{"ast":null,"code":"/**\n * Absolute value. abs(a)==a if a>=0. abs(a)==-a if a<0\n *\n * @param a\n *\n * @returns The absolute value of a\n */\nfunction abs(a) {\n  return a >= 0 ? a : -a;\n}\n/**\n * Returns the bitlength of a number\n *\n * @param a\n * @returns The bit length\n */\n\n\nfunction bitLength(a) {\n  if (typeof a === 'number') a = BigInt(a);\n\n  if (a === 1n) {\n    return 1;\n  }\n\n  let bits = 1;\n\n  do {\n    bits++;\n  } while ((a >>= 1n) > 1n);\n\n  return bits;\n}\n/**\n * An iterative implementation of the extended euclidean algorithm or extended greatest common divisor algorithm.\n * Take positive integers a, b as input, and return a triple (g, x, y), such that ax + by = g = gcd(a, b).\n *\n * @param a\n * @param b\n *\n * @throws {RangeError}\n * This excepction is thrown if a or b are less than 0\n *\n * @returns A triple (g, x, y), such that ax + by = g = gcd(a, b).\n */\n\n\nfunction eGcd(a, b) {\n  if (typeof a === 'number') a = BigInt(a);\n  if (typeof b === 'number') b = BigInt(b);\n  if (a <= 0n || b <= 0n) throw new RangeError('a and b MUST be > 0'); // a and b MUST be positive\n\n  let x = 0n;\n  let y = 1n;\n  let u = 1n;\n  let v = 0n;\n\n  while (a !== 0n) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a;\n    a = r;\n    x = u;\n    y = v;\n    u = m;\n    v = n;\n  }\n\n  return {\n    g: b,\n    x: x,\n    y: y\n  };\n}\n/**\n * Greatest-common divisor of two integers based on the iterative binary algorithm.\n *\n * @param a\n * @param b\n *\n * @returns The greatest common divisor of a and b\n */\n\n\nfunction gcd(a, b) {\n  let aAbs = typeof a === 'number' ? BigInt(abs(a)) : abs(a);\n  let bAbs = typeof b === 'number' ? BigInt(abs(b)) : abs(b);\n\n  if (aAbs === 0n) {\n    return bAbs;\n  } else if (bAbs === 0n) {\n    return aAbs;\n  }\n\n  let shift = 0n;\n\n  while (((aAbs | bAbs) & 1n) === 0n) {\n    aAbs >>= 1n;\n    bAbs >>= 1n;\n    shift++;\n  }\n\n  while ((aAbs & 1n) === 0n) aAbs >>= 1n;\n\n  do {\n    while ((bAbs & 1n) === 0n) bAbs >>= 1n;\n\n    if (aAbs > bAbs) {\n      const x = aAbs;\n      aAbs = bAbs;\n      bAbs = x;\n    }\n\n    bAbs -= aAbs;\n  } while (bAbs !== 0n); // rescale\n\n\n  return aAbs << shift;\n}\n/**\n * The least common multiple computed as abs(a*b)/gcd(a,b)\n * @param a\n * @param b\n *\n * @returns The least common multiple of a and b\n */\n\n\nfunction lcm(a, b) {\n  if (typeof a === 'number') a = BigInt(a);\n  if (typeof b === 'number') b = BigInt(b);\n  if (a === 0n && b === 0n) return BigInt(0);\n  return abs(a * b) / gcd(a, b);\n}\n/**\n * Maximum. max(a,b)==a if a>=b. max(a,b)==b if a<=b\n *\n * @param a\n * @param b\n *\n * @returns Maximum of numbers a and b\n */\n\n\nfunction max(a, b) {\n  return a >= b ? a : b;\n}\n/**\n * Minimum. min(a,b)==b if a>=b. min(a,b)==a if a<=b\n *\n * @param a\n * @param b\n *\n * @returns Minimum of numbers a and b\n */\n\n\nfunction min(a, b) {\n  return a >= b ? b : a;\n}\n/**\n * Finds the smallest positive element that is congruent to a in modulo n\n *\n * @remarks\n * a and b must be the same type, either number or bigint\n *\n * @param a - An integer\n * @param n - The modulo\n *\n * @throws {RangeError}\n * Excpeption thrown when n is not > 0\n *\n * @returns A bigint with the smallest positive representation of a modulo n\n */\n\n\nfunction toZn(a, n) {\n  if (typeof a === 'number') a = BigInt(a);\n  if (typeof n === 'number') n = BigInt(n);\n\n  if (n <= 0n) {\n    throw new RangeError('n must be > 0');\n  }\n\n  const aZn = a % n;\n  return aZn < 0n ? aZn + n : aZn;\n}\n/**\n * Modular inverse.\n *\n * @param a The number to find an inverse for\n * @param n The modulo\n *\n * @throws {RangeError}\n * Excpeption thorwn when a does not have inverse modulo n\n *\n * @returns The inverse modulo n\n */\n\n\nfunction modInv(a, n) {\n  const egcd = eGcd(toZn(a, n), n);\n\n  if (egcd.g !== 1n) {\n    throw new RangeError(`${a.toString()} does not have inverse modulo ${n.toString()}`); // modular inverse does not exist\n  } else {\n    return toZn(egcd.x, n);\n  }\n}\n/**\n * Modular exponentiation b**e mod n. Currently using the right-to-left binary method\n *\n * @param b base\n * @param e exponent\n * @param n modulo\n *\n * @throws {RangeError}\n * Excpeption thrown when n is not > 0\n *\n * @returns b**e mod n\n */\n\n\nfunction modPow(b, e, n) {\n  if (typeof b === 'number') b = BigInt(b);\n  if (typeof e === 'number') e = BigInt(e);\n  if (typeof n === 'number') n = BigInt(n);\n\n  if (n <= 0n) {\n    throw new RangeError('n must be > 0');\n  } else if (n === 1n) {\n    return 0n;\n  }\n\n  b = toZn(b, n);\n\n  if (e < 0n) {\n    return modInv(modPow(b, abs(e), n), n);\n  }\n\n  let r = 1n;\n\n  while (e > 0) {\n    if (e % 2n === 1n) {\n      r = r * b % n;\n    }\n\n    e = e / 2n;\n    b = b ** 2n % n;\n  }\n\n  return r;\n}\n\nfunction fromBuffer(buf) {\n  let ret = 0n;\n\n  for (const i of buf.values()) {\n    const bi = BigInt(i);\n    ret = (ret << 8n) + bi;\n  }\n\n  return ret;\n}\n/**\n * Secure random bytes for both node and browsers. Node version uses crypto.randomBytes() and browser one self.crypto.getRandomValues()\n *\n * @param byteLength - The desired number of random bytes\n * @param forceLength - If we want to force the output to have a bit length of 8*byteLength. It basically forces the msb to be 1\n *\n * @throws {RangeError}\n * byteLength MUST be > 0\n *\n * @returns A promise that resolves to a UInt8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bytes\n */\n\n\nfunction randBytes(byteLength, forceLength = false) {\n  if (byteLength < 1) throw new RangeError('byteLength MUST be > 0');\n  return new Promise(function (resolve, reject) {\n    {\n      // browser\n      const buf = new Uint8Array(byteLength);\n      self.crypto.getRandomValues(buf); // If fixed length is required we put the first bit to 1 -> to get the necessary bitLength\n\n      if (forceLength) buf[0] = buf[0] | 128;\n      resolve(buf);\n    }\n  });\n}\n/**\n * Secure random bytes for both node and browsers. Node version uses crypto.randomFill() and browser one self.crypto.getRandomValues()\n *\n * @param byteLength - The desired number of random bytes\n * @param forceLength - If we want to force the output to have a bit length of 8*byteLength. It basically forces the msb to be 1\n *\n * @throws {RangeError}\n * byteLength MUST be > 0\n *\n * @returns A UInt8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bytes\n */\n\n\nfunction randBytesSync(byteLength, forceLength = false) {\n  if (byteLength < 1) throw new RangeError('byteLength MUST be > 0');\n  /* eslint-disable no-lone-blocks */\n\n  {\n    // browser\n    const buf = new Uint8Array(byteLength);\n    self.crypto.getRandomValues(buf); // If fixed length is required we put the first bit to 1 -> to get the necessary bitLength\n\n    if (forceLength) buf[0] = buf[0] | 128;\n    return buf;\n  }\n  /* eslint-enable no-lone-blocks */\n}\n/**\n * Secure random bits for both node and browsers. Node version uses crypto.randomFill() and browser one self.crypto.getRandomValues()\n *\n * @param bitLength - The desired number of random bits\n * @param forceLength - If we want to force the output to have a specific bit length. It basically forces the msb to be 1\n *\n * @throws {RangeError}\n * bitLength MUST be > 0\n *\n * @returns A Promise that resolves to a UInt8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bits\n */\n\n\nfunction randBits(bitLength, forceLength = false) {\n  if (bitLength < 1) throw new RangeError('bitLength MUST be > 0');\n  const byteLength = Math.ceil(bitLength / 8);\n  const bitLengthMod8 = bitLength % 8;\n  return new Promise((resolve, reject) => {\n    randBytes(byteLength, false).then(function (rndBytes) {\n      if (bitLengthMod8 !== 0) {\n        // Fill with 0's the extra bits\n        rndBytes[0] = rndBytes[0] & 2 ** bitLengthMod8 - 1;\n      }\n\n      if (forceLength) {\n        const mask = bitLengthMod8 !== 0 ? 2 ** (bitLengthMod8 - 1) : 128;\n        rndBytes[0] = rndBytes[0] | mask;\n      }\n\n      resolve(rndBytes);\n    });\n  });\n}\n/**\n * Secure random bits for both node and browsers. Node version uses crypto.randomFill() and browser one self.crypto.getRandomValues()\n * @param bitLength - The desired number of random bits\n * @param forceLength - If we want to force the output to have a specific bit length. It basically forces the msb to be 1\n *\n * @throws {RangeError}\n * bitLength MUST be > 0\n *\n * @returns A Uint8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bits\n */\n\n\nfunction randBitsSync(bitLength, forceLength = false) {\n  if (bitLength < 1) throw new RangeError('bitLength MUST be > 0');\n  const byteLength = Math.ceil(bitLength / 8);\n  const rndBytes = randBytesSync(byteLength, false);\n  const bitLengthMod8 = bitLength % 8;\n\n  if (bitLengthMod8 !== 0) {\n    // Fill with 0's the extra bits\n    rndBytes[0] = rndBytes[0] & 2 ** bitLengthMod8 - 1;\n  }\n\n  if (forceLength) {\n    const mask = bitLengthMod8 !== 0 ? 2 ** (bitLengthMod8 - 1) : 128;\n    rndBytes[0] = rndBytes[0] | mask;\n  }\n\n  return rndBytes;\n}\n/**\n * Returns a cryptographically secure random integer between [min,max]. Both numbers must be >=0\n * @param max Returned value will be <= max\n * @param min Returned value will be >= min\n *\n * @throws {RangeError}\n * Arguments MUST be: max > 0 && min >=0 && max > min\n *\n * @returns A cryptographically secure random bigint between [min,max]\n */\n\n\nfunction randBetween(max, min = 1n) {\n  if (max <= 0n || min < 0n || max <= min) throw new RangeError('Arguments MUST be: max > 0 && min >=0 && max > min');\n  const interval = max - min;\n  const bitLen = bitLength(interval);\n  let rnd;\n\n  do {\n    const buf = randBitsSync(bitLen);\n    rnd = fromBuffer(buf);\n  } while (rnd > interval);\n\n  return rnd + min;\n}\n\nfunction _workerUrl(workerCode) {\n  workerCode = `(() => {${workerCode}})()`; // encapsulate IIFE\n\n  const _blob = new Blob([workerCode], {\n    type: 'text/javascript'\n  });\n\n  return window.URL.createObjectURL(_blob);\n}\n\nlet _useWorkers = false; // The following is just to check whether we can use workers\n\n/* eslint-disable no-lone-blocks */\n\n{\n  // Native JS\n  if (self.Worker !== undefined) _useWorkers = true;\n}\n/**\n * The test first tries if any of the first 250 small primes are a factor of the input number and then passes several\n * iterations of Miller-Rabin Probabilistic Primality Test (FIPS 186-4 C.3.1)\n *\n * @param w - A positive integer to be tested for primality\n * @param iterations - The number of iterations for the primality test. The value shall be consistent with Table C.1, C.2 or C.3\n * @param disableWorkers - Disable the use of workers for the primality test\n *\n * @throws {RangeError}\n * w MUST be >= 0\n *\n * @returns A promise that resolves to a boolean that is either true (a probably prime number) or false (definitely composite)\n */\n\nfunction isProbablyPrime(w, iterations = 16, disableWorkers = false) {\n  if (typeof w === 'number') {\n    w = BigInt(w);\n  }\n\n  if (w < 0n) throw RangeError('w MUST be >= 0');\n  {\n    // browser\n    return new Promise((resolve, reject) => {\n      const worker = new Worker(_isProbablyPrimeWorkerUrl());\n\n      worker.onmessage = event => {\n        worker.terminate();\n        resolve(event.data.isPrime);\n      };\n\n      worker.onmessageerror = event => {\n        reject(event);\n      };\n\n      const msg = {\n        rnd: w,\n        iterations: iterations,\n        id: 0\n      };\n      worker.postMessage(msg);\n    });\n  }\n}\n\nfunction _isProbablyPrime(w, iterations) {\n  /*\n  PREFILTERING. Even values but 2 are not primes, so don't test.\n  1 is not a prime and the M-R algorithm needs w>1.\n  */\n  if (w === 2n) return true;else if ((w & 1n) === 0n || w === 1n) return false;\n  /*\n    Test if any of the first 250 small primes are a factor of w. 2 is not tested because it was already tested above.\n    */\n\n  const firstPrimes = [3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 43n, 47n, 53n, 59n, 61n, 67n, 71n, 73n, 79n, 83n, 89n, 97n, 101n, 103n, 107n, 109n, 113n, 127n, 131n, 137n, 139n, 149n, 151n, 157n, 163n, 167n, 173n, 179n, 181n, 191n, 193n, 197n, 199n, 211n, 223n, 227n, 229n, 233n, 239n, 241n, 251n, 257n, 263n, 269n, 271n, 277n, 281n, 283n, 293n, 307n, 311n, 313n, 317n, 331n, 337n, 347n, 349n, 353n, 359n, 367n, 373n, 379n, 383n, 389n, 397n, 401n, 409n, 419n, 421n, 431n, 433n, 439n, 443n, 449n, 457n, 461n, 463n, 467n, 479n, 487n, 491n, 499n, 503n, 509n, 521n, 523n, 541n, 547n, 557n, 563n, 569n, 571n, 577n, 587n, 593n, 599n, 601n, 607n, 613n, 617n, 619n, 631n, 641n, 643n, 647n, 653n, 659n, 661n, 673n, 677n, 683n, 691n, 701n, 709n, 719n, 727n, 733n, 739n, 743n, 751n, 757n, 761n, 769n, 773n, 787n, 797n, 809n, 811n, 821n, 823n, 827n, 829n, 839n, 853n, 857n, 859n, 863n, 877n, 881n, 883n, 887n, 907n, 911n, 919n, 929n, 937n, 941n, 947n, 953n, 967n, 971n, 977n, 983n, 991n, 997n, 1009n, 1013n, 1019n, 1021n, 1031n, 1033n, 1039n, 1049n, 1051n, 1061n, 1063n, 1069n, 1087n, 1091n, 1093n, 1097n, 1103n, 1109n, 1117n, 1123n, 1129n, 1151n, 1153n, 1163n, 1171n, 1181n, 1187n, 1193n, 1201n, 1213n, 1217n, 1223n, 1229n, 1231n, 1237n, 1249n, 1259n, 1277n, 1279n, 1283n, 1289n, 1291n, 1297n, 1301n, 1303n, 1307n, 1319n, 1321n, 1327n, 1361n, 1367n, 1373n, 1381n, 1399n, 1409n, 1423n, 1427n, 1429n, 1433n, 1439n, 1447n, 1451n, 1453n, 1459n, 1471n, 1481n, 1483n, 1487n, 1489n, 1493n, 1499n, 1511n, 1523n, 1531n, 1543n, 1549n, 1553n, 1559n, 1567n, 1571n, 1579n, 1583n, 1597n];\n\n  for (let i = 0; i < firstPrimes.length && firstPrimes[i] <= w; i++) {\n    const p = firstPrimes[i];\n    if (w === p) return true;else if (w % p === 0n) return false;\n  }\n  /*\n    1. Let a be the largest integer such that 2**a divides w−1.\n    2. m = (w−1) / 2**a.\n    3. wlen = len (w).\n    4. For i = 1 to iterations do\n        4.1 Obtain a string b of wlen bits from an RBG.\n        Comment: Ensure that 1 < b < w−1.\n        4.2 If ((b ≤ 1) or (b ≥ w−1)), then go to step 4.1.\n        4.3 z = b**m mod w.\n        4.4 If ((z = 1) or (z = w − 1)), then go to step 4.7.\n        4.5 For j = 1 to a − 1 do.\n        4.5.1 z = z**2 mod w.\n        4.5.2 If (z = w−1), then go to step 4.7.\n        4.5.3 If (z = 1), then go to step 4.6.\n        4.6 Return COMPOSITE.\n        4.7 Continue.\n        Comment: Increment i for the do-loop in step 4.\n    5. Return PROBABLY PRIME.\n    */\n\n\n  let a = 0n;\n  const d = w - 1n;\n  let aux = d;\n\n  while (aux % 2n === 0n) {\n    aux /= 2n;\n    ++a;\n  }\n\n  const m = d / 2n ** a;\n\n  do {\n    const b = randBetween(d, 2n);\n    let z = modPow(b, m, w);\n    if (z === 1n || z === d) continue;\n    let j = 1;\n\n    while (j < a) {\n      z = modPow(z, 2n, w);\n      if (z === d) break;\n      if (z === 1n) return false;\n      j++;\n    }\n\n    if (z !== d) return false;\n  } while (--iterations !== 0);\n\n  return true;\n}\n\nfunction _isProbablyPrimeWorkerUrl() {\n  // Let's us first add all the required functions\n  let workerCode = `'use strict';const ${eGcd.name}=${eGcd.toString()};const ${modInv.name}=${modInv.toString()};const ${modPow.name}=${modPow.toString()};const ${toZn.name}=${toZn.toString()};const ${randBitsSync.name}=${randBitsSync.toString()};const ${randBytesSync.name}=${randBytesSync.toString()};const ${randBetween.name}=${randBetween.toString()};const ${isProbablyPrime.name}=${_isProbablyPrime.toString()};${bitLength.toString()};${fromBuffer.toString()};`;\n  workerCode += `onmessage=async function(_e){const _m={isPrime:await ${isProbablyPrime.name}(_e.data.rnd,_e.data.iterations),value:_e.data.rnd,id:_e.data.id};postMessage(_m);}`;\n  return _workerUrl(workerCode);\n}\n/**\n * A probably-prime (Miller-Rabin), cryptographically-secure, random-number generator.\n * The browser version uses web workers to parallelise prime look up. Therefore, it does not lock the UI\n * main process, and it can be much faster (if several cores or cpu are available).\n * The node version can also use worker_threads if they are available (enabled by default with Node 11 and\n * and can be enabled at runtime executing node --experimental-worker with node >=10.5.0).\n *\n * @param bitLength - The required bit length for the generated prime\n * @param iterations - The number of iterations for the Miller-Rabin Probabilistic Primality Test\n *\n * @throws {RangeError}\n * bitLength MUST be > 0\n *\n * @returns A promise that resolves to a bigint probable prime of bitLength bits.\n */\n\n\nfunction prime(bitLength, iterations = 16) {\n  if (bitLength < 1) throw new RangeError('bitLength MUST be > 0');\n  /* istanbul ignore if */\n\n  if (!_useWorkers) {\n    // If there is no support for workers\n    let rnd = 0n;\n\n    do {\n      rnd = fromBuffer(randBitsSync(bitLength, true));\n    } while (!_isProbablyPrime(rnd, iterations));\n\n    return new Promise(resolve => {\n      resolve(rnd);\n    });\n  }\n\n  return new Promise((resolve, reject) => {\n    const workerList = [];\n\n    const _onmessage = (msg, newWorker) => {\n      if (msg.isPrime) {\n        // if a prime number has been found, stop all the workers, and return it\n        for (let j = 0; j < workerList.length; j++) {\n          workerList[j].terminate();\n        }\n\n        while (workerList.length > 0) {\n          workerList.pop();\n        }\n\n        resolve(msg.value);\n      } else {\n        // if a composite is found, make the worker test another random number\n        const buf = randBitsSync(bitLength, true);\n        const rnd = fromBuffer(buf);\n\n        try {\n          const msgToWorker = {\n            rnd: rnd,\n            iterations: iterations,\n            id: msg.id\n          };\n          newWorker.postMessage(msgToWorker);\n        } catch (error) {// The worker has already terminated. There is nothing to handle here\n        }\n      }\n    };\n\n    {\n      // browser\n      const workerURL = _isProbablyPrimeWorkerUrl();\n\n      for (let i = 0; i < self.navigator.hardwareConcurrency - 1; i++) {\n        const newWorker = new Worker(workerURL);\n\n        newWorker.onmessage = event => _onmessage(event.data, newWorker);\n\n        workerList.push(newWorker);\n      }\n    }\n\n    for (let i = 0; i < workerList.length; i++) {\n      randBits(bitLength, true).then(function (buf) {\n        const rnd = fromBuffer(buf);\n        workerList[i].postMessage({\n          rnd: rnd,\n          iterations: iterations,\n          id: i\n        });\n      }).catch(reject);\n    }\n  });\n}\n/**\n * A probably-prime (Miller-Rabin), cryptographically-secure, random-number generator.\n * The sync version is NOT RECOMMENDED since it won't use workers and thus it'll be slower and may freeze thw window in browser's javascript. Please consider using prime() instead.\n *\n * @param bitLength - The required bit length for the generated prime\n * @param iterations - The number of iterations for the Miller-Rabin Probabilistic Primality Test\n *\n * @throws {RangeError}\n * bitLength MUST be > 0\n *\n * @returns A bigint probable prime of bitLength bits.\n */\n\n\nfunction primeSync(bitLength, iterations = 16) {\n  if (bitLength < 1) throw new RangeError('bitLength MUST be > 0');\n  let rnd = 0n;\n\n  do {\n    rnd = fromBuffer(randBitsSync(bitLength, true));\n  } while (!_isProbablyPrime(rnd, iterations));\n\n  return rnd;\n}\n\nexport { abs, bitLength, eGcd, gcd, isProbablyPrime, lcm, max, min, modInv, modPow, prime, primeSync, randBetween, randBits, randBitsSync, randBytes, randBytesSync, toZn };","map":{"version":3,"sources":["C:/SCCBD/PROYECTO FINAL/Proyecto_Ciber-main2222/frontend/node_modules/bigint-crypto-utils/dist/esm/index.browser.js"],"names":["abs","a","bitLength","BigInt","bits","eGcd","b","RangeError","x","y","u","v","q","r","m","n","g","gcd","aAbs","bAbs","shift","lcm","max","min","toZn","aZn","modInv","egcd","toString","modPow","e","fromBuffer","buf","ret","i","values","bi","randBytes","byteLength","forceLength","Promise","resolve","reject","Uint8Array","self","crypto","getRandomValues","randBytesSync","randBits","Math","ceil","bitLengthMod8","then","rndBytes","mask","randBitsSync","randBetween","interval","bitLen","rnd","_workerUrl","workerCode","_blob","Blob","type","window","URL","createObjectURL","_useWorkers","Worker","undefined","isProbablyPrime","w","iterations","disableWorkers","worker","_isProbablyPrimeWorkerUrl","onmessage","event","terminate","data","isPrime","onmessageerror","msg","id","postMessage","_isProbablyPrime","firstPrimes","length","p","d","aux","z","j","name","prime","workerList","_onmessage","newWorker","pop","value","msgToWorker","error","workerURL","navigator","hardwareConcurrency","push","catch","primeSync"],"mappings":"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","sourcesContent":["/**\n * Absolute value. abs(a)==a if a>=0. abs(a)==-a if a<0\n *\n * @param a\n *\n * @returns The absolute value of a\n */\nfunction abs(a) {\n    return (a >= 0) ? a : -a;\n}\n\n/**\n * Returns the bitlength of a number\n *\n * @param a\n * @returns The bit length\n */\nfunction bitLength(a) {\n    if (typeof a === 'number')\n        a = BigInt(a);\n    if (a === 1n) {\n        return 1;\n    }\n    let bits = 1;\n    do {\n        bits++;\n    } while ((a >>= 1n) > 1n);\n    return bits;\n}\n\n/**\n * An iterative implementation of the extended euclidean algorithm or extended greatest common divisor algorithm.\n * Take positive integers a, b as input, and return a triple (g, x, y), such that ax + by = g = gcd(a, b).\n *\n * @param a\n * @param b\n *\n * @throws {RangeError}\n * This excepction is thrown if a or b are less than 0\n *\n * @returns A triple (g, x, y), such that ax + by = g = gcd(a, b).\n */\nfunction eGcd(a, b) {\n    if (typeof a === 'number')\n        a = BigInt(a);\n    if (typeof b === 'number')\n        b = BigInt(b);\n    if (a <= 0n || b <= 0n)\n        throw new RangeError('a and b MUST be > 0'); // a and b MUST be positive\n    let x = 0n;\n    let y = 1n;\n    let u = 1n;\n    let v = 0n;\n    while (a !== 0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - (u * q);\n        const n = y - (v * q);\n        b = a;\n        a = r;\n        x = u;\n        y = v;\n        u = m;\n        v = n;\n    }\n    return {\n        g: b,\n        x: x,\n        y: y\n    };\n}\n\n/**\n * Greatest-common divisor of two integers based on the iterative binary algorithm.\n *\n * @param a\n * @param b\n *\n * @returns The greatest common divisor of a and b\n */\nfunction gcd(a, b) {\n    let aAbs = (typeof a === 'number') ? BigInt(abs(a)) : abs(a);\n    let bAbs = (typeof b === 'number') ? BigInt(abs(b)) : abs(b);\n    if (aAbs === 0n) {\n        return bAbs;\n    }\n    else if (bAbs === 0n) {\n        return aAbs;\n    }\n    let shift = 0n;\n    while (((aAbs | bAbs) & 1n) === 0n) {\n        aAbs >>= 1n;\n        bAbs >>= 1n;\n        shift++;\n    }\n    while ((aAbs & 1n) === 0n)\n        aAbs >>= 1n;\n    do {\n        while ((bAbs & 1n) === 0n)\n            bAbs >>= 1n;\n        if (aAbs > bAbs) {\n            const x = aAbs;\n            aAbs = bAbs;\n            bAbs = x;\n        }\n        bAbs -= aAbs;\n    } while (bAbs !== 0n);\n    // rescale\n    return aAbs << shift;\n}\n\n/**\n * The least common multiple computed as abs(a*b)/gcd(a,b)\n * @param a\n * @param b\n *\n * @returns The least common multiple of a and b\n */\nfunction lcm(a, b) {\n    if (typeof a === 'number')\n        a = BigInt(a);\n    if (typeof b === 'number')\n        b = BigInt(b);\n    if (a === 0n && b === 0n)\n        return BigInt(0);\n    return abs(a * b) / gcd(a, b);\n}\n\n/**\n * Maximum. max(a,b)==a if a>=b. max(a,b)==b if a<=b\n *\n * @param a\n * @param b\n *\n * @returns Maximum of numbers a and b\n */\nfunction max(a, b) {\n    return (a >= b) ? a : b;\n}\n\n/**\n * Minimum. min(a,b)==b if a>=b. min(a,b)==a if a<=b\n *\n * @param a\n * @param b\n *\n * @returns Minimum of numbers a and b\n */\nfunction min(a, b) {\n    return (a >= b) ? b : a;\n}\n\n/**\n * Finds the smallest positive element that is congruent to a in modulo n\n *\n * @remarks\n * a and b must be the same type, either number or bigint\n *\n * @param a - An integer\n * @param n - The modulo\n *\n * @throws {RangeError}\n * Excpeption thrown when n is not > 0\n *\n * @returns A bigint with the smallest positive representation of a modulo n\n */\nfunction toZn(a, n) {\n    if (typeof a === 'number')\n        a = BigInt(a);\n    if (typeof n === 'number')\n        n = BigInt(n);\n    if (n <= 0n) {\n        throw new RangeError('n must be > 0');\n    }\n    const aZn = a % n;\n    return (aZn < 0n) ? aZn + n : aZn;\n}\n\n/**\n * Modular inverse.\n *\n * @param a The number to find an inverse for\n * @param n The modulo\n *\n * @throws {RangeError}\n * Excpeption thorwn when a does not have inverse modulo n\n *\n * @returns The inverse modulo n\n */\nfunction modInv(a, n) {\n    const egcd = eGcd(toZn(a, n), n);\n    if (egcd.g !== 1n) {\n        throw new RangeError(`${a.toString()} does not have inverse modulo ${n.toString()}`); // modular inverse does not exist\n    }\n    else {\n        return toZn(egcd.x, n);\n    }\n}\n\n/**\n * Modular exponentiation b**e mod n. Currently using the right-to-left binary method\n *\n * @param b base\n * @param e exponent\n * @param n modulo\n *\n * @throws {RangeError}\n * Excpeption thrown when n is not > 0\n *\n * @returns b**e mod n\n */\nfunction modPow(b, e, n) {\n    if (typeof b === 'number')\n        b = BigInt(b);\n    if (typeof e === 'number')\n        e = BigInt(e);\n    if (typeof n === 'number')\n        n = BigInt(n);\n    if (n <= 0n) {\n        throw new RangeError('n must be > 0');\n    }\n    else if (n === 1n) {\n        return 0n;\n    }\n    b = toZn(b, n);\n    if (e < 0n) {\n        return modInv(modPow(b, abs(e), n), n);\n    }\n    let r = 1n;\n    while (e > 0) {\n        if ((e % 2n) === 1n) {\n            r = r * b % n;\n        }\n        e = e / 2n;\n        b = b ** 2n % n;\n    }\n    return r;\n}\n\nfunction fromBuffer(buf) {\n    let ret = 0n;\n    for (const i of buf.values()) {\n        const bi = BigInt(i);\n        ret = (ret << 8n) + bi;\n    }\n    return ret;\n}\n\n/**\n * Secure random bytes for both node and browsers. Node version uses crypto.randomBytes() and browser one self.crypto.getRandomValues()\n *\n * @param byteLength - The desired number of random bytes\n * @param forceLength - If we want to force the output to have a bit length of 8*byteLength. It basically forces the msb to be 1\n *\n * @throws {RangeError}\n * byteLength MUST be > 0\n *\n * @returns A promise that resolves to a UInt8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bytes\n */\nfunction randBytes(byteLength, forceLength = false) {\n    if (byteLength < 1)\n        throw new RangeError('byteLength MUST be > 0');\n    return new Promise(function (resolve, reject) {\n        { // browser\n            const buf = new Uint8Array(byteLength);\n            self.crypto.getRandomValues(buf);\n            // If fixed length is required we put the first bit to 1 -> to get the necessary bitLength\n            if (forceLength)\n                buf[0] = buf[0] | 128;\n            resolve(buf);\n        }\n    });\n}\n/**\n * Secure random bytes for both node and browsers. Node version uses crypto.randomFill() and browser one self.crypto.getRandomValues()\n *\n * @param byteLength - The desired number of random bytes\n * @param forceLength - If we want to force the output to have a bit length of 8*byteLength. It basically forces the msb to be 1\n *\n * @throws {RangeError}\n * byteLength MUST be > 0\n *\n * @returns A UInt8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bytes\n */\nfunction randBytesSync(byteLength, forceLength = false) {\n    if (byteLength < 1)\n        throw new RangeError('byteLength MUST be > 0');\n    /* eslint-disable no-lone-blocks */\n    { // browser\n        const buf = new Uint8Array(byteLength);\n        self.crypto.getRandomValues(buf);\n        // If fixed length is required we put the first bit to 1 -> to get the necessary bitLength\n        if (forceLength)\n            buf[0] = buf[0] | 128;\n        return buf;\n    }\n    /* eslint-enable no-lone-blocks */\n}\n\n/**\n * Secure random bits for both node and browsers. Node version uses crypto.randomFill() and browser one self.crypto.getRandomValues()\n *\n * @param bitLength - The desired number of random bits\n * @param forceLength - If we want to force the output to have a specific bit length. It basically forces the msb to be 1\n *\n * @throws {RangeError}\n * bitLength MUST be > 0\n *\n * @returns A Promise that resolves to a UInt8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bits\n */\nfunction randBits(bitLength, forceLength = false) {\n    if (bitLength < 1)\n        throw new RangeError('bitLength MUST be > 0');\n    const byteLength = Math.ceil(bitLength / 8);\n    const bitLengthMod8 = bitLength % 8;\n    return new Promise((resolve, reject) => {\n        randBytes(byteLength, false).then(function (rndBytes) {\n            if (bitLengthMod8 !== 0) {\n                // Fill with 0's the extra bits\n                rndBytes[0] = rndBytes[0] & (2 ** bitLengthMod8 - 1);\n            }\n            if (forceLength) {\n                const mask = (bitLengthMod8 !== 0) ? 2 ** (bitLengthMod8 - 1) : 128;\n                rndBytes[0] = rndBytes[0] | mask;\n            }\n            resolve(rndBytes);\n        });\n    });\n}\n/**\n * Secure random bits for both node and browsers. Node version uses crypto.randomFill() and browser one self.crypto.getRandomValues()\n * @param bitLength - The desired number of random bits\n * @param forceLength - If we want to force the output to have a specific bit length. It basically forces the msb to be 1\n *\n * @throws {RangeError}\n * bitLength MUST be > 0\n *\n * @returns A Uint8Array/Buffer (Browser/Node.js) filled with cryptographically secure random bits\n */\nfunction randBitsSync(bitLength, forceLength = false) {\n    if (bitLength < 1)\n        throw new RangeError('bitLength MUST be > 0');\n    const byteLength = Math.ceil(bitLength / 8);\n    const rndBytes = randBytesSync(byteLength, false);\n    const bitLengthMod8 = bitLength % 8;\n    if (bitLengthMod8 !== 0) {\n        // Fill with 0's the extra bits\n        rndBytes[0] = rndBytes[0] & (2 ** bitLengthMod8 - 1);\n    }\n    if (forceLength) {\n        const mask = (bitLengthMod8 !== 0) ? 2 ** (bitLengthMod8 - 1) : 128;\n        rndBytes[0] = rndBytes[0] | mask;\n    }\n    return rndBytes;\n}\n\n/**\n * Returns a cryptographically secure random integer between [min,max]. Both numbers must be >=0\n * @param max Returned value will be <= max\n * @param min Returned value will be >= min\n *\n * @throws {RangeError}\n * Arguments MUST be: max > 0 && min >=0 && max > min\n *\n * @returns A cryptographically secure random bigint between [min,max]\n */\nfunction randBetween(max, min = 1n) {\n    if (max <= 0n || min < 0n || max <= min)\n        throw new RangeError('Arguments MUST be: max > 0 && min >=0 && max > min');\n    const interval = max - min;\n    const bitLen = bitLength(interval);\n    let rnd;\n    do {\n        const buf = randBitsSync(bitLen);\n        rnd = fromBuffer(buf);\n    } while (rnd > interval);\n    return rnd + min;\n}\n\nfunction _workerUrl(workerCode) {\n    workerCode = `(() => {${workerCode}})()`; // encapsulate IIFE\n    const _blob = new Blob([workerCode], { type: 'text/javascript' });\n    return window.URL.createObjectURL(_blob);\n}\nlet _useWorkers = false; // The following is just to check whether we can use workers\n/* eslint-disable no-lone-blocks */\n{ // Native JS\n    if (self.Worker !== undefined)\n        _useWorkers = true;\n}\n\n/**\n * The test first tries if any of the first 250 small primes are a factor of the input number and then passes several\n * iterations of Miller-Rabin Probabilistic Primality Test (FIPS 186-4 C.3.1)\n *\n * @param w - A positive integer to be tested for primality\n * @param iterations - The number of iterations for the primality test. The value shall be consistent with Table C.1, C.2 or C.3\n * @param disableWorkers - Disable the use of workers for the primality test\n *\n * @throws {RangeError}\n * w MUST be >= 0\n *\n * @returns A promise that resolves to a boolean that is either true (a probably prime number) or false (definitely composite)\n */\nfunction isProbablyPrime(w, iterations = 16, disableWorkers = false) {\n    if (typeof w === 'number') {\n        w = BigInt(w);\n    }\n    if (w < 0n)\n        throw RangeError('w MUST be >= 0');\n    { // browser\n        return new Promise((resolve, reject) => {\n            const worker = new Worker(_isProbablyPrimeWorkerUrl());\n            worker.onmessage = (event) => {\n                worker.terminate();\n                resolve(event.data.isPrime);\n            };\n            worker.onmessageerror = (event) => {\n                reject(event);\n            };\n            const msg = {\n                rnd: w,\n                iterations: iterations,\n                id: 0\n            };\n            worker.postMessage(msg);\n        });\n    }\n}\nfunction _isProbablyPrime(w, iterations) {\n    /*\n    PREFILTERING. Even values but 2 are not primes, so don't test.\n    1 is not a prime and the M-R algorithm needs w>1.\n    */\n    if (w === 2n)\n        return true;\n    else if ((w & 1n) === 0n || w === 1n)\n        return false;\n    /*\n      Test if any of the first 250 small primes are a factor of w. 2 is not tested because it was already tested above.\n      */\n    const firstPrimes = [\n        3n,\n        5n,\n        7n,\n        11n,\n        13n,\n        17n,\n        19n,\n        23n,\n        29n,\n        31n,\n        37n,\n        41n,\n        43n,\n        47n,\n        53n,\n        59n,\n        61n,\n        67n,\n        71n,\n        73n,\n        79n,\n        83n,\n        89n,\n        97n,\n        101n,\n        103n,\n        107n,\n        109n,\n        113n,\n        127n,\n        131n,\n        137n,\n        139n,\n        149n,\n        151n,\n        157n,\n        163n,\n        167n,\n        173n,\n        179n,\n        181n,\n        191n,\n        193n,\n        197n,\n        199n,\n        211n,\n        223n,\n        227n,\n        229n,\n        233n,\n        239n,\n        241n,\n        251n,\n        257n,\n        263n,\n        269n,\n        271n,\n        277n,\n        281n,\n        283n,\n        293n,\n        307n,\n        311n,\n        313n,\n        317n,\n        331n,\n        337n,\n        347n,\n        349n,\n        353n,\n        359n,\n        367n,\n        373n,\n        379n,\n        383n,\n        389n,\n        397n,\n        401n,\n        409n,\n        419n,\n        421n,\n        431n,\n        433n,\n        439n,\n        443n,\n        449n,\n        457n,\n        461n,\n        463n,\n        467n,\n        479n,\n        487n,\n        491n,\n        499n,\n        503n,\n        509n,\n        521n,\n        523n,\n        541n,\n        547n,\n        557n,\n        563n,\n        569n,\n        571n,\n        577n,\n        587n,\n        593n,\n        599n,\n        601n,\n        607n,\n        613n,\n        617n,\n        619n,\n        631n,\n        641n,\n        643n,\n        647n,\n        653n,\n        659n,\n        661n,\n        673n,\n        677n,\n        683n,\n        691n,\n        701n,\n        709n,\n        719n,\n        727n,\n        733n,\n        739n,\n        743n,\n        751n,\n        757n,\n        761n,\n        769n,\n        773n,\n        787n,\n        797n,\n        809n,\n        811n,\n        821n,\n        823n,\n        827n,\n        829n,\n        839n,\n        853n,\n        857n,\n        859n,\n        863n,\n        877n,\n        881n,\n        883n,\n        887n,\n        907n,\n        911n,\n        919n,\n        929n,\n        937n,\n        941n,\n        947n,\n        953n,\n        967n,\n        971n,\n        977n,\n        983n,\n        991n,\n        997n,\n        1009n,\n        1013n,\n        1019n,\n        1021n,\n        1031n,\n        1033n,\n        1039n,\n        1049n,\n        1051n,\n        1061n,\n        1063n,\n        1069n,\n        1087n,\n        1091n,\n        1093n,\n        1097n,\n        1103n,\n        1109n,\n        1117n,\n        1123n,\n        1129n,\n        1151n,\n        1153n,\n        1163n,\n        1171n,\n        1181n,\n        1187n,\n        1193n,\n        1201n,\n        1213n,\n        1217n,\n        1223n,\n        1229n,\n        1231n,\n        1237n,\n        1249n,\n        1259n,\n        1277n,\n        1279n,\n        1283n,\n        1289n,\n        1291n,\n        1297n,\n        1301n,\n        1303n,\n        1307n,\n        1319n,\n        1321n,\n        1327n,\n        1361n,\n        1367n,\n        1373n,\n        1381n,\n        1399n,\n        1409n,\n        1423n,\n        1427n,\n        1429n,\n        1433n,\n        1439n,\n        1447n,\n        1451n,\n        1453n,\n        1459n,\n        1471n,\n        1481n,\n        1483n,\n        1487n,\n        1489n,\n        1493n,\n        1499n,\n        1511n,\n        1523n,\n        1531n,\n        1543n,\n        1549n,\n        1553n,\n        1559n,\n        1567n,\n        1571n,\n        1579n,\n        1583n,\n        1597n\n    ];\n    for (let i = 0; i < firstPrimes.length && (firstPrimes[i] <= w); i++) {\n        const p = firstPrimes[i];\n        if (w === p)\n            return true;\n        else if (w % p === 0n)\n            return false;\n    }\n    /*\n      1. Let a be the largest integer such that 2**a divides w−1.\n      2. m = (w−1) / 2**a.\n      3. wlen = len (w).\n      4. For i = 1 to iterations do\n          4.1 Obtain a string b of wlen bits from an RBG.\n          Comment: Ensure that 1 < b < w−1.\n          4.2 If ((b ≤ 1) or (b ≥ w−1)), then go to step 4.1.\n          4.3 z = b**m mod w.\n          4.4 If ((z = 1) or (z = w − 1)), then go to step 4.7.\n          4.5 For j = 1 to a − 1 do.\n          4.5.1 z = z**2 mod w.\n          4.5.2 If (z = w−1), then go to step 4.7.\n          4.5.3 If (z = 1), then go to step 4.6.\n          4.6 Return COMPOSITE.\n          4.7 Continue.\n          Comment: Increment i for the do-loop in step 4.\n      5. Return PROBABLY PRIME.\n      */\n    let a = 0n;\n    const d = w - 1n;\n    let aux = d;\n    while (aux % 2n === 0n) {\n        aux /= 2n;\n        ++a;\n    }\n    const m = d / (2n ** a);\n    do {\n        const b = randBetween(d, 2n);\n        let z = modPow(b, m, w);\n        if (z === 1n || z === d)\n            continue;\n        let j = 1;\n        while (j < a) {\n            z = modPow(z, 2n, w);\n            if (z === d)\n                break;\n            if (z === 1n)\n                return false;\n            j++;\n        }\n        if (z !== d)\n            return false;\n    } while (--iterations !== 0);\n    return true;\n}\nfunction _isProbablyPrimeWorkerUrl() {\n    // Let's us first add all the required functions\n    let workerCode = `'use strict';const ${eGcd.name}=${eGcd.toString()};const ${modInv.name}=${modInv.toString()};const ${modPow.name}=${modPow.toString()};const ${toZn.name}=${toZn.toString()};const ${randBitsSync.name}=${randBitsSync.toString()};const ${randBytesSync.name}=${randBytesSync.toString()};const ${randBetween.name}=${randBetween.toString()};const ${isProbablyPrime.name}=${_isProbablyPrime.toString()};${bitLength.toString()};${fromBuffer.toString()};`;\n    workerCode += `onmessage=async function(_e){const _m={isPrime:await ${isProbablyPrime.name}(_e.data.rnd,_e.data.iterations),value:_e.data.rnd,id:_e.data.id};postMessage(_m);}`;\n    return _workerUrl(workerCode);\n}\n\n/**\n * A probably-prime (Miller-Rabin), cryptographically-secure, random-number generator.\n * The browser version uses web workers to parallelise prime look up. Therefore, it does not lock the UI\n * main process, and it can be much faster (if several cores or cpu are available).\n * The node version can also use worker_threads if they are available (enabled by default with Node 11 and\n * and can be enabled at runtime executing node --experimental-worker with node >=10.5.0).\n *\n * @param bitLength - The required bit length for the generated prime\n * @param iterations - The number of iterations for the Miller-Rabin Probabilistic Primality Test\n *\n * @throws {RangeError}\n * bitLength MUST be > 0\n *\n * @returns A promise that resolves to a bigint probable prime of bitLength bits.\n */\nfunction prime(bitLength, iterations = 16) {\n    if (bitLength < 1)\n        throw new RangeError('bitLength MUST be > 0');\n    /* istanbul ignore if */\n    if (!_useWorkers) { // If there is no support for workers\n        let rnd = 0n;\n        do {\n            rnd = fromBuffer(randBitsSync(bitLength, true));\n        } while (!_isProbablyPrime(rnd, iterations));\n        return new Promise((resolve) => { resolve(rnd); });\n    }\n    return new Promise((resolve, reject) => {\n        const workerList = [];\n        const _onmessage = (msg, newWorker) => {\n            if (msg.isPrime) {\n                // if a prime number has been found, stop all the workers, and return it\n                for (let j = 0; j < workerList.length; j++) {\n                    workerList[j].terminate();\n                }\n                while (workerList.length > 0) {\n                    workerList.pop();\n                }\n                resolve(msg.value);\n            }\n            else { // if a composite is found, make the worker test another random number\n                const buf = randBitsSync(bitLength, true);\n                const rnd = fromBuffer(buf);\n                try {\n                    const msgToWorker = {\n                        rnd: rnd,\n                        iterations: iterations,\n                        id: msg.id\n                    };\n                    newWorker.postMessage(msgToWorker);\n                }\n                catch (error) {\n                    // The worker has already terminated. There is nothing to handle here\n                }\n            }\n        };\n        { // browser\n            const workerURL = _isProbablyPrimeWorkerUrl();\n            for (let i = 0; i < self.navigator.hardwareConcurrency - 1; i++) {\n                const newWorker = new Worker(workerURL);\n                newWorker.onmessage = (event) => _onmessage(event.data, newWorker);\n                workerList.push(newWorker);\n            }\n        }\n        for (let i = 0; i < workerList.length; i++) {\n            randBits(bitLength, true).then(function (buf) {\n                const rnd = fromBuffer(buf);\n                workerList[i].postMessage({\n                    rnd: rnd,\n                    iterations: iterations,\n                    id: i\n                });\n            }).catch(reject);\n        }\n    });\n}\n/**\n * A probably-prime (Miller-Rabin), cryptographically-secure, random-number generator.\n * The sync version is NOT RECOMMENDED since it won't use workers and thus it'll be slower and may freeze thw window in browser's javascript. Please consider using prime() instead.\n *\n * @param bitLength - The required bit length for the generated prime\n * @param iterations - The number of iterations for the Miller-Rabin Probabilistic Primality Test\n *\n * @throws {RangeError}\n * bitLength MUST be > 0\n *\n * @returns A bigint probable prime of bitLength bits.\n */\nfunction primeSync(bitLength, iterations = 16) {\n    if (bitLength < 1)\n        throw new RangeError('bitLength MUST be > 0');\n    let rnd = 0n;\n    do {\n        rnd = fromBuffer(randBitsSync(bitLength, true));\n    } while (!_isProbablyPrime(rnd, iterations));\n    return rnd;\n}\n\nexport { abs, bitLength, eGcd, gcd, isProbablyPrime, lcm, max, min, modInv, modPow, prime, primeSync, randBetween, randBits, randBitsSync, randBytes, randBytesSync, toZn };\n"]},"metadata":{},"sourceType":"module"}